<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="yes" name="apple-touch-fullscreen"><meta content="telephone=no,email=no" name="format-detection"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet"><script src="https://use.fontawesome.com/adaf0e149c.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/monokai_sublime.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/markdown-github.css"><title>上善若水</title><script src="/js/googleAnalytics.js"></script></head><body><div id="postContainer"><div id="postTop"><h4 id="logo">junehappylove</h4><br><br><h2 id="postTitle">Angular Module声明和获取重载</h2><br><span aria-hidden="true" class="postTime fa fa-calendar">2017-5-26</span><span aria-hidden="true" class="postTags fa fa-tags">&nbsp;angular</span><br><br></div><section id="articleDiv"><p>module是angular中重要的模块组织方式，它提供了将一组内聚的业务组件（controller、service、filter、directive…）封装在一起的能力。这样做可以将代码按照业务领域问题分module的封装，然后利用module的依赖注入其关联的模块内容，使得我们能够更好的”分离关注点“，达到更好的”高内聚低耦合“。”高内聚低耦合“是来自面向对象设计原则。内聚是指模块或者对象内部的完整性，一组紧密联系的逻辑应该被封装在同一模块、对象等代码单元中，而不是分散在各处；耦合则指模块、对象等代码单元之间的依赖程度，如果一个模块的修改，会影响到另一个模块，则说明这两模块之间是相互依赖紧耦合的。</p><br><p>同时module也是我们angular代码的入口，首先需要声明module，然后才能定义angular中的其他组件元素，如controller、service、filter、directive、config代码块、run代码块等。</p><br><p>关于module的定义为：angular.module(‘com.ngbook.demo’, [])。关于module函数可以传递3个参数，它们分别为：</p><br><ol><br><li>name：模块定义的名称，它应该是一个唯一的必选参数，它会在后边被其他模块注入或者是在ngAPP指令中声明应用程序主模块；</li><br><li>requires：模块的依赖，它是声明本模块需要依赖的其他模块的参数。特别注意：如果在这里没有声明模块的依赖，则我们是无法在模块中使用依赖模块的任何组件的；它是个可选参数。</li><br><li>configFn： 模块的启动配置函数，在angular config阶段会调用该函数，对模块中的组件进行实例化对象实例之前的特定配置，如我们常见的对$routeProvider配置应用程序的路由信息。它等同于”module.config“函数，建议用”module.config“函数替换它。这也是个可选参数。</li><br></ol><br><p>对于angular.module方法，我们常用的方式有有种，分别为angular.module(‘com.ngbook.demo’, [可选依赖])和angular.module(‘com.ngbook.demo’)。请注意它是完全不同的方式，一个是声明创建module，而另外一个则是获取已经声明了的module。在应用程序中，对module的声明应该有且只有一次；对于获取module，则可以有多次。推荐将angular组件独立分离在不同的文件中，module文件中声明module，其他组件则引入module，需要注意的是在打包或者script方式引入的时候，我们需要首先加载module声明文件，然后才能加载其他组件模块。</p><br><p>在angular中文社区群中，有时会听见某些同学问关于”ng:areq“的错误：</p><br><pre><code>[ng:areq] Argument &apos;DemoCtrl&apos; is not a function, got undefined！<br></code></pre><p>这往往是因为忘记定义controller或者是声明了多次module，多次声明module会导致前边的module定义信息被清空，所以程序就会找不到已定义的组件。这我们也能从angular源码中了解到（来自loader.js）：</p><br><pre><code>function setupModuleLoader(window) {<br>        …<br>        function ensure(obj, name, factory) {<br>            return obj[name] || (obj[name] = factory());<br>        }<br>        var angular = ensure(window, &apos;angular&apos;, Object);<br>        return ensure(angular, &apos;module&apos;, function() {<br>            var modules = {};<br>            return function module(name, requires, configFn) {<br>                var assertNotHasOwnProperty = function(name, context) {<br>                    if (name === &apos;hasOwnProperty&apos;) {<br>                        throw ngMinErr(&apos;badname&apos;, &apos;hasOwnProperty is not a valid {0} name&apos;, context);<br>                    }<br>                };<br><br>                assertNotHasOwnProperty(name, &apos;module&apos;);<br>                if (requires &amp;&amp; modules.hasOwnProperty(name)) {<br>                    modules[name] = null;<br>                }<br>                return ensure(modules, name, function() {<br>                    if (!requires) {<br>                        throw $injectorMinErr(&apos;nomod&apos;, &quot;Module &apos;{0}&apos; is not available! You either misspelled &quot; +<br>                            &quot;the module name or forgot to load it. If registering a module ensure that you &quot; +<br>                            &quot;specify the dependencies as the second argument.&quot;, name);<br>                    }<br>                    var invokeQueue = [];<br>                    var runBlocks = [];<br>                    var config = invokeLater(&apos;$injector&apos;, &apos;invoke&apos;);<br>                    var moduleInstance = {<br>                        _invokeQueue: invokeQueue,<br>                        _runBlocks: runBlocks,<br>                        requires: requires,<br>                        name: name,<br>                        provider: invokeLater(&apos;$provide&apos;, &apos;provider&apos;),<br>                        factory: invokeLater(&apos;$provide&apos;, &apos;factory&apos;),<br>                        service: invokeLater(&apos;$provide&apos;, &apos;service&apos;),<br>                        value: invokeLater(&apos;$provide&apos;, &apos;value&apos;),<br>                        constant: invokeLater(&apos;$provide&apos;, &apos;constant&apos;, &apos;unshift&apos;),<br>                        animation: invokeLater(&apos;$animateProvider&apos;, &apos;register&apos;),<br>                        filter: invokeLater(&apos;$filterProvider&apos;, &apos;register&apos;),<br>                        controller: invokeLater(&apos;$controllerProvider&apos;, &apos;register&apos;),<br>                        directive: invokeLater(&apos;$compileProvider&apos;, &apos;directive&apos;),<br>                        config: config,<br>                        run: function(block) {<br>                            runBlocks.push(block);<br>                            return this;<br>                        }<br>                    };<br>                    if (configFn) {<br>                        config(configFn);<br>                    }<br>                    return moduleInstance;<br><br>                    function invokeLater(provider, method, insertMethod) {<br>                        return function() {<br>                            invokeQueue<a href="[provider, method, arguments]">insertMethod || &apos;push&apos;</a>;<br>                            return moduleInstance;<br>                        };<br>                    }<br>                });<br>            };<br>        });<br>    }<br></code></pre><p>在代码中，我们能了解到angular在启动时，会设置全局的angular对象，然后在angular对象上发布module这个API。关于module API代码，能清晰的看见第一行谓语句，module名称不能以hasOwnProperty命名，否则会抛出”badname“的错误信息。紧接着，如果传入了name参数，其表示是声明module，则会删除已有的module信息，将其置为null。</p><br><p>从moduleInstance的定义，我们能够看出，angular.module为我们公开的API有：invokeQueue、runBlocks、requires、name、provider、factory、servic、value、constant、animation、filter、controller、directive、config、run。其中invokeQueue和runBlocks是按名约定的私有属性，请不要随意使用，其他API都是我们常用的angular组件定义方法，从invokeLater代码中能看到这类angular组件定义的返回依然是moduleInstance实例，这就形成了流畅API，推荐使用链式定义这些组件，而不是声明一个全局的module变量。</p><br><p>最后，如果传入了第三个参数configFn，则会将它配置到config信息中，当angular进入config阶段时，它们将会依次执行，进行对angular应用或者angular组件如service等的实例化前的配置。</p>
</section></div><script src="/js/jquery.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/start.js"></script></body></html>